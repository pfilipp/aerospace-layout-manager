#!/bin/bash

# AeroSpace Layout from Dump-Tree
# Recreates a layout from aerospace dump-tree JSON output
#
# Usage:
#   ./aerospace-layout-from-dump.sh <workspace> <json_file>
#   ./aerospace-layout-from-dump.sh <workspace> < dump.json
#   aerospace dump-tree --workspace temp | ./aerospace-layout-from-dump.sh <workspace>

set -euo pipefail

# =============================================================================
# CONFIGURATION
# =============================================================================

TEMP_WORKSPACE="${AEROSPACE_TEMP_WORKSPACE:-temp}"
DEBUG="${DEBUG:-0}"

# =============================================================================
# LOGGING
# =============================================================================

log() {
    echo "[LAYOUT-DUMP] $*" >&2
}

debug() {
    if [[ "$DEBUG" == "1" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

error() {
    echo "[ERROR] $*" >&2
}

# =============================================================================
# WINDOW MATCHING
# =============================================================================

# Find a window by bundle-id with flexible title matching
# Matching priority:
#   1. If title is empty → return first window with this bundle-id
#   2. Exact title match
#   3. Substring match (title contained in window title)
#   4. Case-insensitive substring match
# Optional: source_workspace - if provided and title is empty, only search this workspace
# Returns window-id or empty string
find_window_by_bundle_and_title() {
    local bundle_id="$1"
    local title="$2"
    local source_workspace="${3:-}"

    debug "Looking for window: bundle='$bundle_id' title='$title' source_workspace='$source_workspace'"

    # Get windows with this bundle id
    # If title is empty AND source_workspace is specified, only search that workspace
    local windows
    if [[ -z "$title" && -n "$source_workspace" ]]; then
        windows=$(aerospace list-windows --workspace "$source_workspace" --app-bundle-id "$bundle_id" --format "%{window-id}|%{window-title}" 2>/dev/null || echo "")
    else
        windows=$(aerospace list-windows --monitor all --app-bundle-id "$bundle_id" --format "%{window-id}|%{window-title}" 2>/dev/null || echo "")
    fi

    if [[ -z "$windows" ]]; then
        debug "No windows found for bundle: $bundle_id"
        echo ""
        return
    fi

    # If title is empty, return first window with this bundle-id
    if [[ -z "$title" ]]; then
        local first_wid
        first_wid=$(echo "$windows" | head -1 | cut -d'|' -f1)
        debug "Empty title - returning first window: $first_wid"
        echo "$first_wid"
        return
    fi

    # Collect windows for multi-pass matching
    local -a wids=()
    local -a wtitles=()
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        wids+=("${line%%|*}")
        wtitles+=("${line#*|}")
    done <<< "$windows"

    # Pass 1: Exact match
    for i in "${!wids[@]}"; do
        if [[ "${wtitles[$i]}" == "$title" ]]; then
            debug "Found exact match: window-id=${wids[$i]}"
            echo "${wids[$i]}"
            return
        fi
    done

    # Pass 2: Substring match (title contained in window title)
    for i in "${!wids[@]}"; do
        if [[ "${wtitles[$i]}" == *"$title"* ]]; then
            debug "Found substring match: window-id=${wids[$i]} (title contains '$title')"
            echo "${wids[$i]}"
            return
        fi
    done

    # Pass 3: Case-insensitive substring match
    local title_lower
    title_lower=$(echo "$title" | tr '[:upper:]' '[:lower:]')
    for i in "${!wids[@]}"; do
        local wtitle_lower
        wtitle_lower=$(echo "${wtitles[$i]}" | tr '[:upper:]' '[:lower:]')
        if [[ "$wtitle_lower" == *"$title_lower"* ]]; then
            debug "Found case-insensitive match: window-id=${wids[$i]}"
            echo "${wids[$i]}"
            return
        fi
    done

    debug "No match found for '$title'"
    echo ""
}

# =============================================================================
# JSON PARSING (using jq)
# =============================================================================

# Check if jq is available
check_dependencies() {
    if ! command -v jq &> /dev/null; then
        error "jq is required but not installed. Install with: brew install jq"
        exit 1
    fi
    if ! command -v aerospace &> /dev/null; then
        error "aerospace is required but not installed or not in PATH"
        exit 1
    fi
}

# Extract workspace info from dump-tree JSON
# Input: full dump-tree JSON (array of workspaces)
# Output: workspace name from JSON
get_workspace_from_dump() {
    local json="$1"
    echo "$json" | jq -r '.[0].name // empty'
}

# Get root container from dump
get_root_container() {
    local json="$1"
    echo "$json" | jq -c '.[0]["root-container"]'
}

# =============================================================================
# TREE TRAVERSAL AND WINDOW DISCOVERY
# =============================================================================

# Recursively collect all windows from the tree
# Returns JSON array of {bundle_id, title, original_id, source_workspace}
collect_windows() {
    local node="$1"

    local node_type
    node_type=$(echo "$node" | jq -r '.type // empty')

    if [[ "$node_type" == "window" ]]; then
        # It's a window - extract info (including optional source-workspace)
        echo "$node" | jq -c '{
            bundle_id: .["app-bundle-id"],
            title: .title,
            original_id: .["window-id"],
            source_workspace: .["source-workspace"] // ""
        }'
    elif [[ "$node_type" == "container" ]]; then
        # It's a container - recurse into children
        local children
        children=$(echo "$node" | jq -c '.children[]?' 2>/dev/null || echo "")
        while IFS= read -r child; do
            if [[ -n "$child" ]]; then
                collect_windows "$child"
            fi
        done <<< "$children"
    fi
}

# Find all windows and create a mapping from original_id to new_id
# Returns JSON object mapping original_id -> new_id
# Exits with error if any window not found
create_window_mapping() {
    local root_container="$1"

    log "Discovering windows from dump..."

    local windows
    windows=$(collect_windows "$root_container")

    local mapping="{}"
    local missing=()

    while IFS= read -r window_info; do
        if [[ -z "$window_info" ]]; then
            continue
        fi

        local bundle_id title original_id source_workspace
        bundle_id=$(echo "$window_info" | jq -r '.bundle_id')
        title=$(echo "$window_info" | jq -r '.title')
        original_id=$(echo "$window_info" | jq -r '.original_id')
        source_workspace=$(echo "$window_info" | jq -r '.source_workspace // empty')

        debug "Finding window: $bundle_id '$title' (original: $original_id, source: $source_workspace)"

        local new_id
        new_id=$(find_window_by_bundle_and_title "$bundle_id" "$title" "$source_workspace")

        if [[ -z "$new_id" ]]; then
            missing+=("$bundle_id: $title")
        else
            log "  Found: $bundle_id '$title' -> $new_id"
            mapping=$(echo "$mapping" | jq --arg orig "$original_id" --arg new "$new_id" '. + {($orig): $new}')
        fi
    done <<< "$windows"

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing windows (not found by bundle-id AND title):"
        for m in "${missing[@]}"; do
            error "  - $m"
        done
        exit 1
    fi

    echo "$mapping"
}

# =============================================================================
# LAYOUT RECREATION
# =============================================================================

# Clear ALL windows from target workspace to temp (clean slate)
# This MUST be done first to ensure the workspace is empty before recreation
clear_workspace_to_temp() {
    local workspace="$1"

    log "Clearing all windows from workspace '$workspace' to '$TEMP_WORKSPACE'..."

    # Get all windows currently on the target workspace
    local windows_on_workspace
    windows_on_workspace=$(aerospace list-windows --workspace "$workspace" --format "%{window-id}" 2>/dev/null || echo "")

    if [[ -z "$windows_on_workspace" ]]; then
        debug "No windows on workspace $workspace"
        return
    fi

    local count=0
    while IFS= read -r wid; do
        if [[ -n "$wid" ]]; then
            debug "Moving window $wid from $workspace to $TEMP_WORKSPACE"
            aerospace move-node-to-workspace --window-id "$wid" "$TEMP_WORKSPACE" 2>/dev/null || true
            ((count++))
        fi
    done <<< "$windows_on_workspace"

    log "  Moved $count windows to temp"
}

# Move dump windows to temp workspace (in case they're scattered across workspaces)
clear_dump_windows_to_temp() {
    local mapping="$1"

    log "Moving dump windows to temp workspace: $TEMP_WORKSPACE"

    echo "$mapping" | jq -r 'to_entries[] | .value' | while read -r wid; do
        if [[ -n "$wid" ]]; then
            debug "Moving $wid to $TEMP_WORKSPACE"
            aerospace move-node-to-workspace --window-id "$wid" "$TEMP_WORKSPACE" 2>/dev/null || true
        fi
    done
}

# Move all windows to target workspace in DFS order
move_windows_to_workspace() {
    local root_container="$1"
    local mapping="$2"
    local workspace="$3"

    log "Moving windows to workspace: $workspace"

    move_node_windows "$root_container" "$mapping" "$workspace"
}

# Recursively move windows from a node (DFS order)
move_node_windows() {
    local node="$1"
    local mapping="$2"
    local workspace="$3"

    local node_type
    node_type=$(echo "$node" | jq -r '.type // empty')

    if [[ "$node_type" == "window" ]]; then
        local original_id new_id
        original_id=$(echo "$node" | jq -r '.["window-id"]')
        new_id=$(echo "$mapping" | jq -r --arg id "$original_id" '.[$id] // empty')

        if [[ -n "$new_id" ]]; then
            debug "Moving window $new_id to $workspace"
            aerospace move-node-to-workspace --window-id "$new_id" "$workspace" 2>/dev/null || true
        fi
    elif [[ "$node_type" == "container" ]]; then
        local children
        children=$(echo "$node" | jq -c '.children[]?' 2>/dev/null || echo "")
        while IFS= read -r child; do
            if [[ -n "$child" ]]; then
                move_node_windows "$child" "$mapping" "$workspace"
            fi
        done <<< "$children"
    fi
}

# Get the representative window ID for a node (first window in DFS order)
get_first_window_id() {
    local node="$1"
    local mapping="$2"

    local node_type
    node_type=$(echo "$node" | jq -r '.type // empty')

    if [[ "$node_type" == "window" ]]; then
        local original_id
        original_id=$(echo "$node" | jq -r '.["window-id"]')
        echo "$mapping" | jq -r --arg id "$original_id" '.[$id] // empty'
    elif [[ "$node_type" == "container" ]]; then
        local first_child
        first_child=$(echo "$node" | jq -c '.children[0]?' 2>/dev/null || echo "")
        if [[ -n "$first_child" ]]; then
            get_first_window_id "$first_child" "$mapping"
        fi
    fi
}

# Get the LAST window ID for a node (last window in DFS order)
get_last_window_id() {
    local node="$1"
    local mapping="$2"

    local node_type
    node_type=$(echo "$node" | jq -r '.type // empty')

    if [[ "$node_type" == "window" ]]; then
        local original_id
        original_id=$(echo "$node" | jq -r '.["window-id"]')
        echo "$mapping" | jq -r --arg id "$original_id" '.[$id] // empty'
    elif [[ "$node_type" == "container" ]]; then
        local last_child
        last_child=$(echo "$node" | jq -c '.children[-1]?' 2>/dev/null || echo "")
        if [[ -n "$last_child" ]]; then
            get_last_window_id "$last_child" "$mapping"
        fi
    fi
}

# Determine the join direction based on the CURRENT spatial arrangement
#
# KEY FINDINGS from testing:
# - join-with left/right → creates v_tiles (vertical container)
# - join-with up/down → creates h_tiles (horizontal container)
#
# IMPORTANT: When joining windows to create nested containers, ALL windows are
# still at the FLATTENED ROOT level. The ROOT layout determines their spatial
# arrangement, NOT the target parent's layout.
#
# For v_* root: windows are stacked vertically (DFS order top to bottom)
#   - Focus FIRST window, join-with DOWN → finds next window below
# For h_* root: windows are side by side (DFS order left to right)
#   - Focus FIRST window, join-with RIGHT → finds next window to the right
get_join_direction() {
    local current_layout="$1"
    local target_layout="$2"

    # Determine current spatial arrangement based on the CURRENT root layout
    # (not the target parent, since windows are still at root level)
    local is_vertical=false
    case "$current_layout" in
        "v_tiles"|"v_accordion"|"")
            is_vertical=true
            ;;
        "h_tiles"|"h_accordion")
            is_vertical=false
            ;;
    esac

    if $is_vertical; then
        # Windows are stacked vertically, first is at top
        # Focus first, join-with down finds the next window below
        echo "down"
    else
        # Windows are side by side horizontally, first is at left
        # Focus first, join-with right finds the next window to the right
        echo "right"
    fi
}

# Get the OPPOSITE join direction (for initial join to get correct window order)
#
# When join-with is executed, the FOUND window (in that direction) becomes FIRST
# in the container, and the SOURCE window (focused) becomes SECOND.
#
# To get correct order [A, B] when joining A and B:
# - Focus B (last), join opposite direction → finds A → creates [A, B]
#
# This is used for 2+ window joins to ensure correct order.
get_opposite_join_direction() {
    local current_layout="$1"

    local is_vertical=false
    case "$current_layout" in
        "v_tiles"|"v_accordion"|"")
            is_vertical=true
            ;;
        "h_tiles"|"h_accordion")
            is_vertical=false
            ;;
    esac

    if $is_vertical; then
        # Windows stacked vertically, opposite of "down" is "up"
        echo "up"
    else
        # Windows side by side, opposite of "right" is "left"
        echo "left"
    fi
}

# Apply layout operations recursively (post-order: children first)
#
# UPDATED ALGORITHM based on Phase 1 test findings:
#
# After moving windows in DFS order, they are spatially adjacent.
# The spatial arrangement depends on the CURRENT layout of their parent.
#
# Key insight: Focus the LAST window of a group and join toward the first.
# This works because:
# - In v_* layout: last window is at bottom, join-with up finds previous
# - In h_* layout: last window is at right, join-with left finds previous
#
# Join direction rules (CONFIRMED BY TESTS):
# - join-with left/right → creates v_tiles container
# - join-with up/down → creates h_tiles container
apply_layout() {
    local node="$1"
    local mapping="$2"
    local workspace="$3"
    local root_layout="${4:-}"    # The ROOT container's layout (for spatial arrangement)
    local is_root="${5:-false}"

    local node_type
    node_type=$(echo "$node" | jq -r '.type // empty')

    if [[ "$node_type" != "container" ]]; then
        return
    fi

    local layout
    layout=$(echo "$node" | jq -r '.layout // empty')

    local children_json
    children_json=$(echo "$node" | jq -c '.children // []')

    local num_children
    num_children=$(echo "$children_json" | jq 'length')

    debug "Processing container: layout=$layout, children=$num_children, root_layout=$root_layout, is_root=$is_root"

    if [[ "$num_children" -eq 0 ]]; then
        return
    fi

    # First, recursively process all child containers (post-order traversal)
    # This creates the deepest containers first
    # Pass root_layout unchanged - all joins use the root's spatial arrangement
    local child_idx=0
    while [[ $child_idx -lt $num_children ]]; do
        local child
        child=$(echo "$children_json" | jq -c ".[$child_idx]")
        local child_type
        child_type=$(echo "$child" | jq -r '.type // empty')

        if [[ "$child_type" == "container" ]]; then
            apply_layout "$child" "$mapping" "$workspace" "$root_layout" "false"
        fi

        ((child_idx++))
    done

    # Skip joining for root container - its children are already at root level
    # We only need to set the root layout (done separately in main)
    if [[ "$is_root" == "true" ]]; then
        debug "Skipping join for root container (children already at root level)"
        return
    fi

    # Now join children together to form this NESTED container
    if [[ "$num_children" -gt 1 ]]; then
        # Determine join direction based on ROOT's spatial arrangement
        local join_direction
        join_direction=$(get_join_direction "$root_layout" "$layout")

        debug "Join direction for creating $layout (root=$root_layout): $join_direction"

        # ALGORITHM: Build container with correct window order
        #
        # Key insight: When join-with is executed, the FOUND window (in that
        # direction) becomes FIRST in the container, and the SOURCE window
        # (focused) becomes SECOND.
        #
        # For windows-only container [A, B, C]:
        # - Focus B (second), join up → finds A → creates [A, B]
        # - Focus C (third), move up → C enters container at END → [A, B, C]
        #
        # For container with nested containers, we need special handling:
        # - If second child is a container (already processed), it has been moved
        # - We use FIRST child as anchor, join in FORWARD direction to grab second
        # - This avoids extracting windows from already-created nested containers

        # Get first child info
        local first_child
        first_child=$(echo "$children_json" | jq -c ".[0]")
        local first_child_type
        first_child_type=$(echo "$first_child" | jq -r '.type // empty')
        local first_window_id
        first_window_id=$(get_first_window_id "$first_child" "$mapping")

        # Get second child info
        local second_child
        second_child=$(echo "$children_json" | jq -c ".[1]")
        local second_child_type
        second_child_type=$(echo "$second_child" | jq -r '.type // empty')
        local second_window_id
        second_window_id=$(get_first_window_id "$second_child" "$mapping")

        # Check if any child is a container (already processed in post-order)
        local has_container_children=false
        local child_idx=0
        while [[ $child_idx -lt $num_children ]]; do
            local child_type
            child_type=$(echo "$children_json" | jq -r ".[$child_idx].type // empty")
            if [[ "$child_type" == "container" ]]; then
                has_container_children=true
                break
            fi
            ((child_idx++))
        done

        local opposite_direction
        opposite_direction=$(get_opposite_join_direction "$root_layout")

        if [[ "$has_container_children" == "true" ]]; then
            # Special handling: has nested containers (already created)
            # Focus FIRST window and join FORWARD to avoid extracting from nested containers
            debug "Container has nested container children - using FIRST window as anchor"
            debug "Focusing first window (idx=0): $first_window_id"
            aerospace focus --window-id "$first_window_id" 2>/dev/null || true

            debug "Executing: aerospace join-with $join_direction (joining with $second_window_id)"
            aerospace join-with "$join_direction" 2>/dev/null || true

            # For 3+ children, use move to add remaining
            if [[ "$num_children" -gt 2 ]]; then
                local child_idx=2
                while [[ $child_idx -lt $num_children ]]; do
                    local target_child
                    target_child=$(echo "$children_json" | jq -c ".[$child_idx]")
                    local target_window_id
                    target_window_id=$(get_first_window_id "$target_child" "$mapping")

                    if [[ -n "$target_window_id" ]]; then
                        debug "Executing: aerospace move $join_direction for window $target_window_id (idx=$child_idx)"
                        aerospace focus --window-id "$target_window_id" 2>/dev/null || true
                        aerospace move "$join_direction" 2>/dev/null || true
                    fi

                    ((child_idx++))
                done
            fi
        else
            # Normal case: all children are windows
            # Focus SECOND, join OPPOSITE to get correct order [first, second]
            debug "Focusing second window (idx=1): $second_window_id"
            aerospace focus --window-id "$second_window_id" 2>/dev/null || true

            debug "Executing: aerospace join-with $opposite_direction (joining with $first_window_id)"
            aerospace join-with "$opposite_direction" 2>/dev/null || true

            # For 3+ children, use MOVE to add remaining windows
            if [[ "$num_children" -gt 2 ]]; then
                local child_idx=2
                while [[ $child_idx -lt $num_children ]]; do
                    local target_child
                    target_child=$(echo "$children_json" | jq -c ".[$child_idx]")
                    local target_window_id
                    target_window_id=$(get_first_window_id "$target_child" "$mapping")

                    if [[ -n "$target_window_id" ]]; then
                        debug "Executing: aerospace move $opposite_direction for window $target_window_id (idx=$child_idx)"
                        aerospace focus --window-id "$target_window_id" 2>/dev/null || true
                        aerospace move "$opposite_direction" 2>/dev/null || true
                    fi

                    ((child_idx++))
                done
            fi
        fi
    fi

    # NOTE: Layout is NOT set here anymore - it's done in a separate pass
    # This prevents cascading layout changes during the join phase
    debug "Container joined, layout will be set in second pass"
}

# Second pass: Apply layouts to all containers (post-order traversal)
# This is done after all joins to prevent layout changes from affecting subsequent joins
apply_layouts() {
    local node="$1"
    local mapping="$2"
    local workspace="$3"
    local is_root="${4:-false}"

    local node_type
    node_type=$(echo "$node" | jq -r '.type // empty')

    if [[ "$node_type" != "container" ]]; then
        return
    fi

    local layout
    layout=$(echo "$node" | jq -r '.layout // empty')

    local children_json
    children_json=$(echo "$node" | jq -c '.children // []')

    local num_children
    num_children=$(echo "$children_json" | jq 'length')

    # First, recursively process all child containers
    local child_idx=0
    while [[ $child_idx -lt $num_children ]]; do
        local child
        child=$(echo "$children_json" | jq -c ".[$child_idx]")
        local child_type
        child_type=$(echo "$child" | jq -r '.type // empty')

        if [[ "$child_type" == "container" ]]; then
            apply_layouts "$child" "$mapping" "$workspace" "false"
        fi

        ((child_idx++))
    done

    # Skip root - its layout is already set
    if [[ "$is_root" == "true" ]]; then
        return
    fi

    # Apply the layout type to this container
    if [[ "$num_children" -gt 0 ]]; then
        local first_child
        first_child=$(echo "$children_json" | jq -c '.[0]')
        local rep_window_id
        rep_window_id=$(get_first_window_id "$first_child" "$mapping")

        if [[ -n "$rep_window_id" ]]; then
            debug "Setting layout $layout on container (via window $rep_window_id)"
            aerospace focus --window-id "$rep_window_id" 2>/dev/null || true
            aerospace layout "$layout" 2>/dev/null || true
        fi
    fi
}

# =============================================================================
# MAIN
# =============================================================================

main() {
    check_dependencies

    local target_workspace=""
    local json_input=""

    # Parse arguments
    if [[ $# -lt 1 ]]; then
        echo "Usage: $0 <target_workspace> [json_file]"
        echo "       $0 <target_workspace> < dump.json"
        echo "       aerospace dump-tree --workspace X | $0 <target_workspace>"
        exit 1
    fi

    target_workspace="$1"

    if [[ $# -ge 2 ]]; then
        # JSON file provided as argument
        if [[ ! -f "$2" ]]; then
            error "File not found: $2"
            exit 1
        fi
        json_input=$(cat "$2")
    else
        # Read from stdin
        if [[ -t 0 ]]; then
            error "No JSON input provided. Pipe JSON or provide file path."
            exit 1
        fi
        json_input=$(cat)
    fi

    # Validate JSON
    if ! echo "$json_input" | jq empty 2>/dev/null; then
        error "Invalid JSON input"
        exit 1
    fi

    log "=========================================="
    log "AeroSpace Layout from Dump-Tree"
    log "=========================================="
    log "Target workspace: $target_workspace"
    log "Temp workspace: $TEMP_WORKSPACE"

    # Get root container
    local root_container
    root_container=$(get_root_container "$json_input")

    if [[ -z "$root_container" ]] || [[ "$root_container" == "null" ]]; then
        error "No root-container found in dump"
        exit 1
    fi

    local root_layout
    root_layout=$(echo "$root_container" | jq -r '.layout // "tiles"')
    log "Root layout: $root_layout"

    # Step 1: Clear ALL windows from target workspace to temp (MUST be first!)
    clear_workspace_to_temp "$target_workspace"

    # Step 2: Create window mapping (find all windows from dump)
    local mapping
    mapping=$(create_window_mapping "$root_container")

    local window_count
    window_count=$(echo "$mapping" | jq 'length')
    log "Found $window_count windows"

    # Step 3: Move dump windows to temp (in case they're on other workspaces)
    clear_dump_windows_to_temp "$mapping"

    # Step 4: Switch to target workspace
    log "Switching to workspace: $target_workspace"
    aerospace workspace "$target_workspace"

    # Step 5: Move all windows to target workspace
    move_windows_to_workspace "$root_container" "$mapping" "$target_workspace"

    # Step 6: Flatten workspace and set root layout
    # This ensures all windows are at the same level before we start grouping
    log "Flattening workspace and setting root layout: $root_layout"
    aerospace flatten-workspace-tree --workspace "$target_workspace" 2>/dev/null || true

    # Focus any window in the workspace and set root layout
    local any_window
    any_window=$(echo "$mapping" | jq -r 'to_entries[0].value // empty')
    if [[ -n "$any_window" ]]; then
        aerospace focus --window-id "$any_window" 2>/dev/null || true
        aerospace layout "$root_layout" 2>/dev/null || true
    fi

    # Step 7: Apply layout operations in two phases
    # Phase 1: Create all nested containers via joins
    # Pass root_layout so all joins use the correct spatial arrangement
    # Pass is_root=true for the root container so it doesn't try to join its children
    log "Phase 1: Creating nested containers..."
    apply_layout "$root_container" "$mapping" "$target_workspace" "$root_layout" "true"

    # Phase 2: Apply layouts to all containers
    # Done separately to prevent layout changes from affecting joins
    log "Phase 2: Applying container layouts..."
    apply_layouts "$root_container" "$mapping" "$target_workspace" "true"

    log "=========================================="
    log "Layout recreation complete!"
    log "=========================================="
}

main "$@"
